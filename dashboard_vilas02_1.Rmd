---
title: "Dashboard Vilas 02"
output: flexdashboard::flex_dashboard
orientation: columns
vertical_layout: fill
smooth_scroll: true
runtime: shiny
---


```{r setup, include=FALSE}

library(flexdashboard)
library(dplyr)
library(ggplot2)
library(yaml)


#library(jpeg)

```

```{r}

# Load the googlesheets4 package
library(googlesheets4)
config = yaml.load_file("config.yml")
# Authenticate with Google Sheets (you may be prompted to sign in)
gs4_auth(email=TRUE)

options(date.format = "%d/%m/%y", stringsAsFactors = FALSE)

# Cargar la tabla VL2-R-01-Registro de mediciones
# Get the sheet ID and sheet name

AtoAR <- function(A)
{  AR <- 100/(1+2000/A)
  return(AR) }

sheet_id <- config$sheet_id
sheet_name <- config$sheet_name
# Set the range to read, starting from the fourth row
range <- paste0(sheet_name, config$range)
# Read the sheet data into R as a data frame, using the fourth row as the column names
my_data <- read_sheet(sheet_id, sheet_name, range, col_names = TRUE)

my_data <- my_data %>%
  mutate(
    Fecha = as.Date(Fecha),
    Prueba = as.character(Prueba),
    Medicion = as.character(Medicion),
    Muestra = as.character(Muestra),
    Pmed_base = as.numeric(as.character(Pmed_base)),
    Pmed_A10 = as.numeric(as.character(Pmed_A10)),
    Amplitud_base = as.numeric(as.character(Amplitud_base)),
    A10 = as.numeric(as.character(`A10 (600s+CT) [Pa]`)),
    A1 = as.numeric(as.character(`A1 (60s+CT) [Pa]`)),
    A5 = as.numeric(as.character(`A5 (300s+CT) [Pa]`)),
    A20 = as.numeric(as.character(`A20 (1200s+CT) [Pa]`)),
    CT = as.numeric(as.character(`CT [seg]`)),
    Alpha = as.numeric(as.character(Alpha)),
    Frecuencia_Hz = as.numeric(as.character(Frecuencia_Hz)),
    Nro_Cartucho = as.character(`Nro Cartucho`),
    P_desprendimiento = as.numeric(as.character(`Presion de desprendimiento [Pa]`)),
    Frecuencia = as.numeric(as.character(Frecuencia_Hz)),
    P_canal_abierto_QC2 = as.numeric(as.character(`Canal abierto Promedio QC2 [Pa]`)),
    P_canal_cerrado_QC1 = as.numeric(as.character(`Canal cerrado Promedio QC1 [Pa]`)),
    P_canal_cerrado_QC3 = as.numeric(as.character(`Canal cerrado Promedio QC3 [Pa]`)),
    Activacion = as.character(Activacion),
    Fase_A10 = as.numeric(as.character(Fase_A10)),
    Pasa_criterio_fase = as.character(Pasa_criterio_fase),
    Tz_i = as.numeric(as.character(Tz_i)),
    Tz_A10 = as.numeric(as.character(Tz_A10)),
    Resultado = as.character(Resultado),
    Problema = as.character(Problema),
    .keep = "none"  # Drop all original columns after transformation
  )

# create new columns
cte=.8
my_data <- my_data %>%
  mutate(
    A10R = AtoAR(A10),
    Medicion = paste(Prueba,Medicion) ,
    deltaCC = P_canal_cerrado_QC3-P_canal_cerrado_QC1,
    deltaTz = Tz_A10-Tz_i,
    deltaPmed = Pmed_A10 - Pmed_base,
    A10corregido = (A10 * P_canal_cerrado_QC3)/(cte*P_canal_cerrado_QC3-A10),
    A10Rcorregido = AtoAR(A10corregido)
)

#subset con las mediciones que no tuvieron problemas y tienen datos en A10
subset_data <- subset(my_data, Problema == "ninguno" & !is.na(A10))

# subset donde se aplica quality check y se pone como problema el motivo de falla
my_data_QC <- subset_data
my_data_QC$Problema[my_data_QC$Amplitud_base < config$pbase_min] <- 'QC_failed_Pbase'
my_data_QC$Problema[abs(my_data_QC$deltaPmed) > config$delta_pmed_max ] <- 'delta_Pmed'
my_data_QC$Problema[my_data_QC$P_canal_cerrado_QC1 < config$qc1_min] <- 'canal_cerrado'
my_data_QC$Problema[abs(my_data_QC$deltaPmed) > config$delta_pmed_max & my_data_QC$P_canal_cerrado_QC1 < config$qc1_min] <- 'delta_Pmed & canal_cerrado'
my_data_QC$Problema[my_data_QC$Pasa_criterio_fase == "no"] <- 'no_pasa_fase'
my_data_QC$Problema[abs(my_data_QC$deltaCC) > config$deltaCC_max] <- 'deltaCC_Alto'
my_data_QC$Problema[abs(my_data_QC$deltaTz) > config$deltaTz_max] <- 'deltaTz_Alto'

# actualiza columna Resultado con falsos positivos y falsos negativos del QC
subset_data$Resultado[my_data_QC$Problema !=  'ninguno' & my_data_QC$Resultado == 'Buena'] <- 'Falso_negativo_QC'
subset_data$Resultado[my_data_QC$Problema ==  'ninguno' & my_data_QC$Resultado == 'Mala'] <- 'Falso_positivo_QC'

# subset con las mediciones que pasaron el QC 
subset_data_QC <- subset(my_data_QC, Problema =="ninguno")

```

```{r}

# Common theme settings for plots
common_theme <- theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14),
    axis.text.y = element_text(size = 14)
  )
# my_palette <- c("#FF0000", "#00FF00", "#0000FF", "#FF00FF", "#00FFFF", "#FFFF00",
#                 "#FFA500", "#800080", "#008000", "#000080", "#800000", "#008080",
#                 "#FFC0CB", "#FF6347", "#00CED1", "#8B4513", "#2E8B57", "#DAA520",
#                 "#9932CC", "#FF1493")

# funcion que plotea datos
my_plot <- function(midata, x_col, a_col, color_col, shape_col, plot_type) {
# Read the JPEG image
# img <- readJPEG("felici.jpeg")


switch(plot_type,
scatter = {
   # Create scatter plot using ggplot2
  ggplot(midata, aes(x = .data[[x_col]], y = .data[[a_col]], color = .data[[color_col]], shape = .data[[shape_col]])) +
    geom_point(size= 3) +
    labs(title = paste0(a_col, " vs. ", x_col), x = x_col, y = a_col, color = color_col, shape=shape_col)+
    common_theme+
     # Add vertical lines 
   if (x_col=='Prueba') {
        geom_vline(xintercept = config$pruebas_cambio, linetype = "dashed", color = "red")
    }},
boxplot = {
  # boxplot with labels
  # calculate CV values for each group
  cv_data <- midata %>%
  group_by(.data[[x_col]]) %>%
  summarise(cv = round(100*sd(.data[[a_col]])/mean(.data[[a_col]]), 0))
  #para calcular el N de cada grupo/prueba
  N_data <- midata %>%
  count(.data[[x_col]], name = "N")
  # plot boxplot with CV and N labels
  ggplot(midata, aes(x = .data[[x_col]], y = .data[[a_col]], color = .data[[color_col]])) +
  geom_boxplot() +
  labs(title = paste0(a_col, " vs. ", x_col), x = x_col, y = a_col, color = color_col, shape=shape_col)+
  common_theme+
  geom_text(data = N_data, aes(x = .data[[x_col]], y = min(midata[[a_col]]), label = paste0("", N)), vjust = -1, size = 3, color = "red") +
  geom_text(data = cv_data, aes(x = .data[[x_col]], y = min(midata[[a_col]]), label = paste0("", cv, "%")), vjust = 1, angle =55, size = 3, color = "blue", nudge_x = -0.2)
  
} ,
boxplot_sd = {
  # boxplot with labels
  # calculate CV values for each group
  cv_data <- midata %>%
  group_by(.data[[x_col]]) %>%
  summarise(dcolor=max(.data[[color_col]]) ,mean = mean(.data[[a_col]]), sd = sd(.data[[a_col]]), cv = 100 * sd / mean)

# Calculate the N of each group/practice
  N_data <- midata %>%
  count(.data[[x_col]], name = "N")

# Plot boxplot with CV and N labels
  ggplot(midata, aes(x = .data[[x_col]], y = .data[[a_col]], color = .data[[color_col]])) +
  geom_point(data = cv_data, aes(y = mean,color =dcolor), size = 3) +
  geom_segment(data = cv_data, aes(x = .data[[x_col]], xend=.data[[x_col]],  y = mean - sd, yend = mean + sd, color =dcolor ), size = 1.5) +
  labs(title = paste0(a_col, " vs. ", x_col), x = x_col, y = a_col, color = color_col) +
  common_theme +
  geom_text(data = N_data, aes(x = .data[[x_col]], y = min(midata[[a_col]]), label = paste0("", N)), vjust = -1, size = 3, color = "red", nudge_x = -0.2) +
  geom_text(data = cv_data, aes(x = .data[[x_col]], y = min(midata[[a_col]]), label = paste0("", round(sd,0))), vjust = 1, angle = 0, size = 3, color = "brown", nudge_x = -0.2)+
  geom_text(data = cv_data, aes(x = .data[[x_col]], y = min(midata[[a_col]]), label = paste0("", round(cv,0), "%")), vjust = 3, angle = 0, size = 3, color = "blue", nudge_x = -0.2) +
  geom_text(data = cv_data, aes(x = .data[[x_col]], y = mean, label = paste0("", round(mean,0))), hjust = -1, size = 3, color = "black") 
} ,
sigma_A = {
  # boxplot with labels
  # calculate CV values for each group
  cv_data <- midata %>%
  group_by(Prueba) %>%
  summarise(promedio=mean(.data[[a_col]]),sigma = sd(.data[[a_col]]),muestra=max(Muestra),activacion=max(Activacion))
  
  #para calcular el N de cada grupo/prueba
  N_data <- midata %>%
  count(.data[[x_col]], name = "N")
  
        # This function creates a dataframe of points in a circle around a center point with radius and number of points determined by the input data
        # d: input dataframe with columns for x and y coordinates, circle radius (r), and circle color (circle_color)  n: number of points around the circle (default = 30)
        circularise <- function(d, n=30){
          angle <- seq(-pi, pi, length = n)
          make_circle <- function(x,y,r,id, circle_color){data.frame(x=x+r*cos(angle), y=y+r*sin(angle), id, circle_color)}
          lmat <- mapply(make_circle, id = seq_len(nrow(d)), x = 0, y=d[["promedio"]], r=d[["sigma"]],circle_color=d[["muestra"]], SIMPLIFY = FALSE)
          do.call(rbind, lmat)
        }
  
  circles <- circularise(cv_data)
  p <- ggplot() + geom_point(data=cv_data, aes(x=0, y=promedio))
  p + geom_polygon(aes(x, y, group=id, fill=circle_color, alpha=0.5), data=circles) + coord_fixed()

}
)
}
  
 

```

# Plots

Column {.sidebar}
--------------------------------------------------

```{r}
num_variables <- sort(c('Prueba','Medicion','Fecha','A1','A5','A10','A10R','A20','CT','Amplitud_base','P_canal_abierto_QC2','deltaCC','P_canal_cerrado_QC1','P_canal_cerrado_QC3','P_desprendimiento','Pmed_base','deltaPmed','Alpha','Fase_A10','Tz_i','Tz_A10','deltaTz','A10corregido','A10Rcorregido'))
cat_variables <- sort(c('Prueba','Activacion','Muestra','Comportamiento_curva_pmed','Nro_Cartucho','Picos_curva_pmed','Pasa_criterio_fase','Resultado','Medicion','Fecha'))


selectInput("values_muestra", "Select values for Muestra:", choices = unique(subset_data$Muestra), multiple = TRUE, selected = config$muestra)
selectInput("values_activacion", "Select values for Activacion:", choices = unique(subset_data$Activacion), multiple = TRUE, selected = config$activacion)
selectInput("values_freq", "Select values for Frequency:", choices = unique(subset_data$Frecuencia), multiple = TRUE, selected = '1')
selectInput("plot_type", "Select plot type:", choices = c('scatter','boxplot','boxplot_sd','sigma_A'), multiple = FALSE,selected ='scatter')

selectInput("x_var", "Select X axis variable:", choices = num_variables, multiple = FALSE, selected ='Prueba') 
selectInput("y_var", "Select Y axis variable:", choices = num_variables, multiple = FALSE, selected ='A10')

selectInput("color_var", "Select color variable:", choices = cat_variables, multiple = FALSE, selected ='Muestra')
selectInput("shape_var", "Select shape variable:", choices = cat_variables, multiple = FALSE, selected ='Activacion')

dateRangeInput("date_range", "Select date range:", 
                 start = as.Date(config$date_from), end = Sys.Date(), 
                 format = "yyyy-mm-dd", separator = " to ")

checkboxInput("aplicar_QC", "Aplicar QC", FALSE)
actionButton("save_button", "Save Selection")

# numericInput("constante", label = "Enter a Number:", value = 1, min = 0, max = 10)

```

Column {data-width=650}
-----------------------------------------------------------------------

### Chart A

```{r}


# Define a function to apply common filtering
applyCommonFilter <- function(data, input) {
  filtered_data <- subset(data,
    Muestra %in% input$values_muestra &
    Activacion %in% input$values_activacion &
    Fecha >= input$date_range[1] &
    Fecha <= input$date_range[2] &
    Frecuencia_Hz %in% input$values_freq
  )
  return(filtered_data)
}
# Filtra todas las mediciones según selección de la gui
reactive_my_data <- reactive({
  data_to_use <- if (input$aplicar_QC) my_data_QC else my_data
  # Apply common filtering using the function
  filtered_data <- applyCommonFilter(data_to_use, input)
  return(filtered_data)
})
# Filtra las mediciones sin problemas según selección de la gui
reactive_subset_data <- reactive({
  data_to_use <- if (input$aplicar_QC) subset_data_QC else subset_data
  # Apply common filtering using the function
  filtered_data <- applyCommonFilter(data_to_use, input)
  return(filtered_data)
})

# Render plot based on plot type, filtered data object and user's selected x, y, shape and color columns
  renderPlot({
    my_plot(midata = reactive_subset_data(), x_col = input$x_var, a_col = input$y_var, color_col = input$color_var,  shape_col = input$shape_var,plot_type=input$plot_type)
  })

# Update the configuration and save to YAML when Save button is clicked
observeEvent(input$save_button, {
  config$muestra <- input$values_muestra
  config$date_from <- input$date_range[1]
  config$activacion <- input$values_activacion
  write_yaml(config, file = "config.yml")
})

```

Column {data-width=350}
-----------------------------------------------------------------------

### Chart B

```{r}
renderPlot({

# Create a frequency table of the "Problema" column
problema_count <- data.frame(table(Problema = reactive_my_data()$Problema))

# Add a column to indicate "ninguno" or "otro"
problema_count$is_ninguno <- ifelse(problema_count$Problema == "ninguno", "ninguno", "otro")

# Summarize the counts by "ninguno" and "otro"
problema_summary <- aggregate(Freq ~ is_ninguno, data = problema_count, sum)

# Plot the summary using a stacked bar plot
ggplot(problema_summary, aes(x = "", y = Freq, fill = is_ninguno)) +  geom_bar(stat = "identity") +
  theme_classic() +  xlab("") +  ylab("Count") +
  ggtitle("Count of rows with 'ninguno' vs other values in 'Problema' column") +
  geom_text(aes(label = paste0(round(Freq / sum(Freq) * 100), "%")), position = position_stack(vjust = 0.5))
})  
  
```

### Chart C

```{r}
library(RColorBrewer)

renderPlot({
# Create a data frame with the count of each value in the "Problema" column
problema_count <- data.frame(table(reactive_my_data()$Problema))

# Remove the rows with "ninguno"
problema_count <- problema_count[problema_count$Var1 != "ninguno", ]

# Set the fill colors using the Paired color palette
fill_colors <- brewer.pal(nrow(problema_count), "Paired")

# Plot the counts of rows by value using a stacked bar plot with contrasting colors
ggplot(problema_count, aes(x = "", y = Freq, fill = Var1)) +
  geom_bar(stat = "identity") +
  theme_classic() +
  xlab("") +
  ylab("Count") +
  ggtitle("Count of rows with values other than 'ninguno' in 'Problema' column, grouped by value") +
  scale_fill_manual(values = fill_colors) +
  geom_text(aes(label = paste0(round(Freq / sum(Freq) * 100), "%")), 
            position = position_stack(vjust = 0.5))
})  
```


# Conclusiones  {.storyboard}

### Eventos en el desarrollo que afectan las mediciones
* Día 14 -- 30/11/22 -- Mejora del dispensado
* Dia 23 -- 13/02/23 -- Cambio de placa
* Dia 34 -- 17/04/23 -- Mejoramos mezclado (se aumenta a 3 el # de mezclados)
* Dia 38 -- 28/04/23 -- Versión de Firmware 2.0.17
* Dia 42 -- 08/05/23 -- Se cambia la frecuencia a 1 Hz  (días previos se comparan frecuencias de 0,5 y 1 Hz)
* Dia 46_jeringa -- 01/06/23 -- Se ajusta la válvula cartucho y se mejora la alineación del émbolo -- Mejora la Presión de base
* Día CT8_SL -- 20/06/23 -- Se lleva el Vilas a la sala limpia para medir en condiciones estables de temperatura
* Día 50 -- 27/06/23 -- Se trae el Vilas al contenedor manteniendo la temperatura del ambiente baja para que sea estable
* Día 66 -- 18/07/23 -- Se modifica el mezclado para dispensar cerca del CT: de 3 a 14 mezclados
* Día 88 -- 04/09/2023 -- Se comienza a medir con mayor cantidad de carrier en el reservorio (llegó el FC770 importado)
* Día 95 -- 13/09/2023 -- Error en toma de datos, cambio del acople luer, ajuste de embolo y cambio de motor de la pipeta
* Día 101 – 26/09/2023 – Se comienza a medir con control de presión media - Mediciones en Home superior
* Día 104 - 29/09/2023 - Mediciones en posición 15 uL y agregado de casita Manifold

### Problemas principales
* Hay una correlación positiva entre A10 y deltaPmed (ver A10 vs deltaPmed). La variabilidad de deltaPmed entre mediciones afecta la repetibilidad de A10. Esto sucede para valores de deltaPmed superiores a aproximadamente 300 Pa. Para valores de deltaPmed más bajos no hay correlación.
* El control de temperatura es insuficiente. El cartucho no alcanza la temperatura determinada.
* La variabilidad en el deltaPmed podría deberse a variaciones en la temperatura del sistema.

### Observaciones más relevantes
* Si bien a partir de la medición 46 (mejora de mecánica) la amplitud de presión de base (Amplitud_base) se mantiene en un valor promedio constante, su variabilidad es mayor que antes (ver Amplitud_base vs. Prueba).
* Se observó una correlación entre el descenso de la amplitud_base y el descenso en A10 para los distintos Rotroles. Esto indica que la incapacidad de diferenciar muestras normales de patológicas se debió a los defectos en la mecánica del equipo, que lo descalibraban progresivamente  (Ver Amplitud_base versus medición o vs fecha y A10 versus Amplitud_base). Además, esto explica que la variación interdía fuera mayor que la intradía, especialmente en Rotrol N donde la correlación de A10 con Amplitud_base es más pronunciada.
* En las mediciones de sangre con problemas más del 40% no coagularon, versus las de ROTROL con problemas en las que 5% no coagularon. El n<20 es bajo.

### Observaciones secundarias
* El CT depende de la temperatura pero deltaPmed depende de los cambios de temperatura durante la medición (con mucha mayor sensibilidad que el CT).
* Los problemas principales antes de la mejora del sistema mecánico (Amplitud de presión de base en descenso) son más notables en ROTROL N y sangre que en Plasma Siemens. 
* No vemos relación entre el error y la presión a canal cerrado (script R plotParametros)
* El error en A10 medido intra cartucho no es menor al inter cartucho. El error en A10 no está causado por diferencias entre cartuchos.
* La presión de ruptura tiene una correlación positiva con el A10. Ver dashboard scatter_A_vs_Pruptura.

### Planificación
* Hacer seguimiento del deltaPmed cuando se corrija el control de temperatura.
* Evaluar si en condiciones más estables de temperatura se estabiliza el deltaPmed (sala limpia)
* Verificar si con los ajustes en la mecánica se logra estabilidad en Pbase
* Evaluar el efecto de la mayor variabilidiad de la presion de base sobre la repetibilidad
* Medir sangre para aumentar el N y evaluar la variabilidad de esta muestra
* Verificar si la mayor variabilidad en muestras más rígidas se mantiene a pesar de las mejoras en la mecánica.
